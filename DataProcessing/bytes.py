import numpy as np

def isPacketLine(readline, word_check):
    if word_check in readline:
        return True

    else:
        return False

def comparePacketManual(packet_str, packet_byte):
    '''
    compare converted packet with manual declaration
    '''
    packet_str_man = 'aaaaaaAI\xd3\xd3\xd3\x9dUt\x10RZZ1\x10\x18\x18\x10\x10\x18\x18\x18\x18\x18\x18\x10\x18\x18\x18\x10\x10\x10\x10\x10\x18\x10\x10\x10\x10\x10\x10\x18\x18\x10\x10\x10\x10\x10\x10rr\x92\x94\x91\x94\x91\x94\x91\x94\x91\x94\x91\x94\x92\x94\xb2\x94\xb2\x94\xb2\x94\xb2\x94\xb2\x94\xd2\x94\xd2\x94\xb2\x94\xd2\x94\xb2\x94\xb2\x9c\xb2\x9c\xb2\x9c\xd2\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xf3\x9c\xd2\x9c\xf2\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xd3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9d\x13\x9c\xf3\x9c\xd3\x9c\xd3\x94\xd3\x9c\xd3\x9c\xf2\x9c\xf3\x9c\xf2\x9d\x13\x9c\xf3\x9c\xf3\xf3\xf3\xf3\xf3\x9c\xf4\xd4\xf4\xf4\xf4\xf4\xf4\xf4\xf4\xf4\x9c\xf4\x9c\xf4\x9d\x13\x9d\x13\x9c\xf3\x9c\xf3\x9d\x13\x9c\xf3\x9d\x14\x9d\x14\x9d\x14\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf2\x9c\xf3\xd3\xd3\xd3\xb3\x9c\xd3\x9c\xb3\xb5\xb5\x13\x9b\xb5\xd844\x145555U\x9dVvv\x96\x96\xb6\xf7\xb6\x18\x18\xb6\x18\xff\xff:\x189\xff\xfd\xd9\xbeX9YY9\xbe99\xbeY\xb68\xb7\xfc\x9b\xbbz\xbe\x19v\x9dVV6VVVvv\x97\x96\x96\x96\x96\xb6\xb6\xd7\xb7\xb5\xd7\xb5\xb7\xb5\xb7\xb5\xb7\xd7\xb5\xd7\xd7\xb5\xf7\xb5\xf8\xb5\xf8\xb5\xf8\xb5\xf8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xb7\xb5\xb8\x16H'
    packet_byte_man = b'aaaaaaAI\xd3\xd3\xd3\x9dUt\x10RZZ1\x10\x18\x18\x10\x10\x18\x18\x18\x18\x18\x18\x10\x18\x18\x18\x10\x10\x10\x10\x10\x18\x10\x10\x10\x10\x10\x10\x18\x18\x10\x10\x10\x10\x10\x10rr\x92\x94\x91\x94\x91\x94\x91\x94\x91\x94\x91\x94\x92\x94\xb2\x94\xb2\x94\xb2\x94\xb2\x94\xb2\x94\xd2\x94\xd2\x94\xb2\x94\xd2\x94\xb2\x94\xb2\x9c\xb2\x9c\xb2\x9c\xd2\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xd3\x9c\xf3\x9c\xd2\x9c\xf2\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xd3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9d\x13\x9c\xf3\x9c\xd3\x9c\xd3\x94\xd3\x9c\xd3\x9c\xf2\x9c\xf3\x9c\xf2\x9d\x13\x9c\xf3\x9c\xf3\xf3\xf3\xf3\xf3\x9c\xf4\xd4\xf4\xf4\xf4\xf4\xf4\xf4\xf4\xf4\x9c\xf4\x9c\xf4\x9d\x13\x9d\x13\x9c\xf3\x9c\xf3\x9d\x13\x9c\xf3\x9d\x14\x9d\x14\x9d\x14\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf3\x9c\xf2\x9c\xf3\xd3\xd3\xd3\xb3\x9c\xd3\x9c\xb3\xb5\xb5\x13\x9b\xb5\xd844\x145555U\x9dVvv\x96\x96\xb6\xf7\xb6\x18\x18\xb6\x18\xff\xff:\x189\xff\xfd\xd9\xbeX9YY9\xbe99\xbeY\xb68\xb7\xfc\x9b\xbbz\xbe\x19v\x9dVV6VVVvv\x97\x96\x96\x96\x96\xb6\xb6\xd7\xb7\xb5\xd7\xb5\xb7\xb5\xb7\xb5\xb7\xd7\xb5\xd7\xd7\xb5\xf7\xb5\xf8\xb5\xf8\xb5\xf8\xb5\xf8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xd8\xb5\xb7\xb5\xb8\x16H'

    packet_str_man = '\xf4\x12\xfa\xd9BH\x00\x02\x17\x16\x17\x16\x15\x16\x16\x16\x13\x11\x12\x12\x12\x14\x17\x1a\x1a\x13\x15\x13\x14\x1b\x15\x14\x18\x19\x11\x12\x12\x13\x18\x17\x15\x13\x13\x13\x15\x14\x14\x15\x13\x12\x14\x1a\x1a\x18\x0f\x13\x1c\x19\x19\x17\x14\x15\x17\x19\x16\x15\x15\x14\x17\x19\x13\x13\x13\x18\x17\x17\x17\x19\x19\x17\x15\x14"\x1f\x18\x15\x15\x15\x15\x14\x14\x15\x16\x15\x15\x17\x14\x14\x14\x14\x15\x16\x1b\x1d\x13\x16\x16\x16\x15\x14\x13\x14\x14\x15\x17\x16\x15\x16\x0e\x12\x14\x16\x15\x14\x13\x17\x17\x15\x12\x1a\x18\x18\x1e\n\x11\x14\x14\x13\x12\x14\x14\x14\x16\x15\x0e\x10\x14\x14\x15\x15\x16\x15\x15\x15\x17\x16\x18\x16\x13\x14\x14\x13\x11\x15\x11\x10\x0e\x11\x12\x16\x14\x11\x12\x11\x12\x12\r\x12\x11\x13\x13\x13\x0f\x0f\x10\x12\x13\x15\x13\x11\x10\x0f\x12\x12\x13\x13\x10\x10\x12\x12\x12\x13\x14\x13\x16\r\x10\x14\x14\x12\x12\x13\x10\x0f\x0f\x0e\x10\x14\x12\x11\x0f\x0f\x11\x1a\x1c\x16\x12\x0f\x0f\x0f\x10\x12\x13\x14\x12\x10\x0e\x0e\x12\x0f\x11\x12\x11\x11\x11\x10\x10\x10\x11\x0e\x10\x0f\x10\x0f\x0c\x0c\x10\x0c\r\x10\x0f\r\r\x11\x11\x0e\x0c\x0e\r\r\x0f\x0f\x0e\x10\x10\x10\x10\x0e\x0e\x10\x0f\x0f\x0f\x10\x0f\x0f\x0f\x0f\r\x0c\x0c\r\x0f\x0f\x0e\r\x0c\n\x08\x08\n\n\x0b\x0c\r\r\r\x0b\n\x0c\x0c\x0b\x0c\t\x08\n\x0e\n\x0b\x0b\x0b\n\n\x0b\r\x0c\x0c\r\x9ay'
    packet_byte_man = b'\xf4\x12\xfa\xd9BH\x00\x02\x17\x16\x17\x16\x15\x16\x16\x16\x13\x11\x12\x12\x12\x14\x17\x1a\x1a\x13\x15\x13\x14\x1b\x15\x14\x18\x19\x11\x12\x12\x13\x18\x17\x15\x13\x13\x13\x15\x14\x14\x15\x13\x12\x14\x1a\x1a\x18\x0f\x13\x1c\x19\x19\x17\x14\x15\x17\x19\x16\x15\x15\x14\x17\x19\x13\x13\x13\x18\x17\x17\x17\x19\x19\x17\x15\x14"\x1f\x18\x15\x15\x15\x15\x14\x14\x15\x16\x15\x15\x17\x14\x14\x14\x14\x15\x16\x1b\x1d\x13\x16\x16\x16\x15\x14\x13\x14\x14\x15\x17\x16\x15\x16\x0e\x12\x14\x16\x15\x14\x13\x17\x17\x15\x12\x1a\x18\x18\x1e\n\x11\x14\x14\x13\x12\x14\x14\x14\x16\x15\x0e\x10\x14\x14\x15\x15\x16\x15\x15\x15\x17\x16\x18\x16\x13\x14\x14\x13\x11\x15\x11\x10\x0e\x11\x12\x16\x14\x11\x12\x11\x12\x12\r\x12\x11\x13\x13\x13\x0f\x0f\x10\x12\x13\x15\x13\x11\x10\x0f\x12\x12\x13\x13\x10\x10\x12\x12\x12\x13\x14\x13\x16\r\x10\x14\x14\x12\x12\x13\x10\x0f\x0f\x0e\x10\x14\x12\x11\x0f\x0f\x11\x1a\x1c\x16\x12\x0f\x0f\x0f\x10\x12\x13\x14\x12\x10\x0e\x0e\x12\x0f\x11\x12\x11\x11\x11\x10\x10\x10\x11\x0e\x10\x0f\x10\x0f\x0c\x0c\x10\x0c\r\x10\x0f\r\r\x11\x11\x0e\x0c\x0e\r\r\x0f\x0f\x0e\x10\x10\x10\x10\x0e\x0e\x10\x0f\x0f\x0f\x10\x0f\x0f\x0f\x0f\r\x0c\x0c\r\x0f\x0f\x0e\r\x0c\n\x08\x08\n\n\x0b\x0c\r\r\r\x0b\n\x0c\x0c\x0b\x0c\t\x08\n\x0e\n\x0b\x0b\x0b\n\n\x0b\r\x0c\x0c\r\x9ay'

    isStrMatch = False
    isByteMatch = False
    if packet_str_man == packet_str:
        isStrMatch = True

    if packet_byte_man == packet_byte:
        isByteMatch = True

    print(f'is packet_str match:{isStrMatch}')
    if not isByteMatch:
        for i in range(len(packet_str_man)):
            print(f'{i} manual:{ord(packet_str_man[i])} in:{ord(packet_str[i])}')

    print(f'is packet_byte match:{isByteMatch}')

def trimStrFromLogFile(readline, trim_front, trim_end):
    # is same with manual
    packet_str = readline[trim_front:trim_end]
    packet_size = len(packet_str)

    return packet_str, packet_size

def preprocessingPacketStr(readline, input_type):
    if input_type == 'log':
        # readline = text that read from file.log
        trim_front = 10
        trim_end = -2
        packet_str, packet_size = trimStrFromLogFile(readline, trim_front, trim_end)

    elif input_type == 'log2':
        # readline = text that read from file.log
        trim_front = 11
        trim_end = -2
        packet_str, packet_size = trimStrFromLogFile(readline, trim_front, trim_end)

    return packet_str

def convertChar2int(packet_str):
    # convert char to imt
    packet_size = len(packet_str)
    list_packet_int = []
    for i in range(packet_size):
        # byte_file = ord(packet_str[i])
        # byte_man = packet_byte_man[i]
        # print(f'byte file:{byte_file} man:{byte_man}')

        # convert char to int
        list_packet_int.append(ord(packet_str[i]))

    return list_packet_int

def convertPacketStr2byte(packet_str, input_type='byte'):
    if 'log' in input_type:
        list_packet_int = convertChar2int(packet_str)

        packet_byte = bytes(list_packet_int)
        # packet_byte4 = bytearray(packet_int)

    elif input_type == 'byte':
        # readline = bytearray from esp32
        # do task here
        print("received data from esp32")

    return packet_byte, len(packet_byte)

def createDictDecode(packet_info, init_none=False):
    dict_decode = {}

    if isinstance(packet_info, list):
        n_header = len(packet_info)

        # for key, val in packet_info:
        for i in range(n_header):
            headerData = packet_info[i]['name']
            if init_none:
                dict_decode[headerData] = None
            else:
                dict_decode[headerData] = []

    elif isinstance(packet_info, dict):
        n_header = 1
        headerData = packet_info['name']
        if init_none:
            dict_decode[headerData] = None
        else:
            dict_decode[headerData] = []

    return dict_decode, n_header

def decodeArrBytesPixel(data_bytes):
    # convert each one bytes
    data_bytes_size = len(data_bytes)
    row_pixel = np.zeros((data_bytes_size), dtype='uint8')

    for ipix in range(data_bytes_size):
        '''
            *just index data_bytes[ipix] is already int
            but if index data_bytes[ipix:ipix+1] is byte        
        '''
        # row_pixel[ipix] = int.from_bytes(data_bytes[ipix])
        row_pixel[ipix] = data_bytes[ipix]

    return row_pixel

def decodeArrBytes(data_byte, data_type):
    if data_type == 'int':
        data_decoded = int.from_bytes(data_byte)

    elif data_type == 'hex':
        data_decoded = data_byte.hex(':')

    elif data_type == 'str':
        # dict_decode[data_name] = data_bytes_str
        data_decoded = data_byte.decode('UTF-8')

    else:
        raise ValueError(f"Not support data_type:{data_type}")

    return data_decoded

def getIndexPacket(packet_info, headerIndexBytes):
    if (len(packet_info[headerIndexBytes]) == 2):
        data_bytes_size = packet_info[headerIndexBytes][1] - packet_info[headerIndexBytes][0] + 1

        istr = packet_info[headerIndexBytes][0]
        iend = packet_info[headerIndexBytes][1]

    elif (len(packet_info[headerIndexBytes]) == 1):
        data_bytes_size = 1

        istr = packet_info[headerIndexBytes][0]
        iend = istr

    '''
    x = [1, 2, 3 ,4, 5]
    x[0] >> 1
    x[1] >> 2
    x[1:2] >> 2
    x[1:3] >> [2, 3]
    '''
    iend = iend + 1

    return istr, iend, data_bytes_size

def chopArrBytes(packet_byte, packet_info, headerIndexBytes):
    if isinstance(packet_info, dict):
        istr, iend, data_bytes_size = getIndexPacket(packet_info, headerIndexBytes)

        data_bytes = packet_byte[istr:iend]

        return data_bytes, data_bytes_size

    else:
        raise ValueError('packet_info must be dict for chop bytes')

def decodePacketByPacketInfo(packet_byte, packet_info, headerIndexBytes, isCompletePacket=True):

    # if isinstance(packet_info, list):
    #     n_header = len(packet_info)
    #
    # elif isinstance(packet_info, dict):
    #     n_header = 1
    dict_decoded, n_header = createDictDecode(packet_info, init_none=not(isCompletePacket))

    if isCompletePacket:
        if n_header > 1:
            for i in range(n_header):
                data_name = packet_info[i]['name']
                data_type = packet_info[i]['type']

                data_bytes, data_n_bytes = chopArrBytes(packet_byte, packet_info[i], headerIndexBytes)

                if data_name == 'data':
                    data_decoded = decodeArrBytesPixel(data_bytes)
                else:
                    data_decoded = decodeArrBytes(data_bytes, data_type)

                dict_decoded[data_name] = data_decoded

        elif n_header == 1:
            data_name = packet_info['name']
            data_type = packet_info['type']

            data_bytes, data_n_bytes = chopArrBytes(packet_byte, packet_info, headerIndexBytes)

            if data_name == 'data':
                data_decoded = decodeArrBytesPixel(data_bytes)
            else:
                data_decoded = decodeArrBytes(data_bytes, data_type)

            dict_decoded[data_name] = data_decoded

    return dict_decoded